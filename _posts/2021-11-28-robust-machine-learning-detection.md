---
title: Robust Machine Learning - Detection
date: 2021-11-28 12:00:00 -0600
categories: [Research]
tags: []     # TAG names should always be lowercase
math: true
---
Relevant paper: [[P1]({{ site.baseurl }}{% link _tabs/research.md %}), [C4]({{ site.baseurl }}{% link _tabs/research.md %})].

The following article examines the problem of *Byzantine* behavior in distributed learning setups from the lens of detection. The problem has been introduced in the [article]({% post_url 2021-11-28-robust-machine-learning-filtering %}) discussing our proposed method *ByzShield*. In this work, our objective is to initially attempt to detect which nodes behave adversarially or erroneously before resorting to gradient aggregation. We consider attack models ranging from strong ones: $q$ omniscient adversaries with full knowledge of the defense protocol that can change from iteration to iteration to weak ones: $q$ randomly chosen adversaries with limited collusion abilities which only change every few iterations at a time. Our algorithms rely on redundant task assignments coupled with detection of adversarial behavior. Specifically, we consider clusters of $K$ workers, where each gradient task is assign to $r$ of them.

We consider two different task assignment schemes, named *Aspis* and *Aspis+*. Aspis is a subset-based scheme and enjoys most benefits in adversarial settings: omniscient, colluding
adversaries, up to q adversaries that can change at each iteration. However, Aspis requires large batch sizes (in the mini-batch SGD). It is [well-recognized](https://arxiv.org/abs/1606.04838){:target="_blank" rel="noopener"} that large batch sizes often cause performance degradation in training. Accordingly, for this class of attacks, we present a different algorithm called Aspis+ that can work with much smaller batch sizes. For Aspis+, we use [combinatorial designs](https://link.springer.com/book/10.1007/b97564){:target="_blank" rel="noopener"} to assign the gradient tasks to workers. Aspis+ is a good fit for clusters that suffer from non-adversarial failures that can lead to inaccurate gradients.

Under strong attacks, we prove that Aspis is optimal in distorting as many files as possible. Even in this adverse scenario, our method enjoys a reduction in the fraction of corrupted gradients of more than 90% compared with [DETOX](https://papers.nips.cc/paper/9220-detox-a-redundancy-based-framework-for-faster-and-more-robust-gradient-aggregation){:target="_blank" rel="noopener"}. A weaker variation of this attack is where the adversaries do not collude and act randomly. In this case, we demonstrate that the Aspis protocol allows for detecting all the adversaries. In both scenarios, we provide theoretical guarantees on the fraction of corrupted gradients; Figure 1 shows a simulation of the distortion fraction and comparison with the baseline method (that assigns one gradient to each worker) as well as the prior state-of-the-art [DETOX](https://papers.nips.cc/paper/9220-detox-a-redundancy-based-framework-for-faster-and-more-robust-gradient-aggregation){:target="_blank" rel="noopener"} under optimal attacks.

![Figure 1](/kostas_files/distortion_fig_107.png){: width="500" }
*Figure 1: Distortion fraction of optimal attacks for $(K,r)=(50,3)$ and comparison.*

The detection mechanism of Aspis is based on clique-finding in appropriate graphs. In our setup, the edges of the utilized graphs encode the agreements of workers. A *clique* in an undirected graph is defined as a subset of vertices with an edge between any pair of them. A *maximal clique* is one that cannot be enlarged by adding additional vertices to it. A *maximum clique* is one such that there is no clique with more vertices in the given graph. In our papers, we prove that the honest workers form a clique of size $K-q$. The clique containing the honest workers may not be maximal. However, it will have a size of at least $K-q$. Any worker $U_j$ with degree less than $K-q-1$ will not belong to a maximum clique and we show that it can right away be eliminated as a "detected" adversary. An example of a successful detection of the adversarial nodes $U_1$, $U_2$, and $U_3$ where the maximum clique is unique and of size $K-q = 4$ is in Figure 2. However, if there are multiple maximum cliques in the graph the ambiguity as to which one is the honest set makes an accurate detection impossible; in this case, we resort to robust aggregation, i.e., a method of filtering discussed in the previous [article]({% post_url 2021-11-28-robust-machine-learning-filtering %}). An example of this case is shown in Figure 3.

![Figure 2](/kostas_files/Subset_assignment_K7_r3_graph_success.png){: width="500" }
*Figure 2: Unique max-clique in the detection graph, detection succeeds.*

![Figure 2](/kostas_files/Subset_assignment_K7_r3_graph_failure.png){: width="500" }
*Figure 2: Two max-cliques in the detection graph, detection fails.*

We note that clique-finding is well-known to be an NP-complete problem (*cf.*, [[Karp, 1972](https://link.springer.com/chapter/10.1007/978-1-4684-2001-2_9){:target="_blank" rel="noopener"}]). Nevertheless, there are fast, practical algorithms with excellent performance on graphs even up to hundreds of nodes (we used that of [[Etsuji et al.](https://www.sciencedirect.com/science/article/pii/S0304397506003586#:~:text=All%20the%20maximal%20cliques%20generated,in%20an%20n%2Dvertex%20graph.){:target="_blank" rel="noopener"}]). Our extensive experimental evidence suggests that clique-finding is not a computation bottleneck for the size and structure of the graphs that Aspis uses. We have experimented with clique-finding on a graph of $K=100$ workers and $r=5$ for different values of $q$; in all cases, enumerating all maximal cliques took no more than 15 milliseconds.

For weaker attacks considered for Aspis+, i.e., when the adversaries change only every few iterations, our results indicate that our scheme detects all adversaries within approximately $5$ iterations. The principal intuition of the Aspis+ detection approach is to iteratively keep refining a graph in which the edges encode the agreements of workers until the degree of some nodes falls below a value; we prove that the workers are Byzantine.